// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package usecase

import (
	"context"
	"github.com/kngnkg/tunetrail/api/entity"
	"sync"
)

// Ensure, that ReviewRepositoryMock does implement ReviewRepository.
// If this is not the case, regenerate this file with moq.
var _ ReviewRepository = &ReviewRepositoryMock{}

// ReviewRepositoryMock is a mock implementation of ReviewRepository.
//
//	func TestSomethingThatUsesReviewRepository(t *testing.T) {
//
//		// make and configure a mocked ReviewRepository
//		mockedReviewRepository := &ReviewRepositoryMock{
//			GetByIdFunc: func(ctx context.Context, reviewId string) (*entity.Review, error) {
//				panic("mock out the GetById method")
//			},
//			StoreFunc: func(ctx context.Context, review *entity.Review) error {
//				panic("mock out the Store method")
//			},
//		}
//
//		// use mockedReviewRepository in code that requires ReviewRepository
//		// and then make assertions.
//
//	}
type ReviewRepositoryMock struct {
	// GetByIdFunc mocks the GetById method.
	GetByIdFunc func(ctx context.Context, reviewId string) (*entity.Review, error)

	// StoreFunc mocks the Store method.
	StoreFunc func(ctx context.Context, review *entity.Review) error

	// calls tracks calls to the methods.
	calls struct {
		// GetById holds details about calls to the GetById method.
		GetById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReviewId is the reviewId argument value.
			ReviewId string
		}
		// Store holds details about calls to the Store method.
		Store []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Review is the review argument value.
			Review *entity.Review
		}
	}
	lockGetById sync.RWMutex
	lockStore   sync.RWMutex
}

// GetById calls GetByIdFunc.
func (mock *ReviewRepositoryMock) GetById(ctx context.Context, reviewId string) (*entity.Review, error) {
	if mock.GetByIdFunc == nil {
		panic("ReviewRepositoryMock.GetByIdFunc: method is nil but ReviewRepository.GetById was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		ReviewId string
	}{
		Ctx:      ctx,
		ReviewId: reviewId,
	}
	mock.lockGetById.Lock()
	mock.calls.GetById = append(mock.calls.GetById, callInfo)
	mock.lockGetById.Unlock()
	return mock.GetByIdFunc(ctx, reviewId)
}

// GetByIdCalls gets all the calls that were made to GetById.
// Check the length with:
//
//	len(mockedReviewRepository.GetByIdCalls())
func (mock *ReviewRepositoryMock) GetByIdCalls() []struct {
	Ctx      context.Context
	ReviewId string
} {
	var calls []struct {
		Ctx      context.Context
		ReviewId string
	}
	mock.lockGetById.RLock()
	calls = mock.calls.GetById
	mock.lockGetById.RUnlock()
	return calls
}

// Store calls StoreFunc.
func (mock *ReviewRepositoryMock) Store(ctx context.Context, review *entity.Review) error {
	if mock.StoreFunc == nil {
		panic("ReviewRepositoryMock.StoreFunc: method is nil but ReviewRepository.Store was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Review *entity.Review
	}{
		Ctx:    ctx,
		Review: review,
	}
	mock.lockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	mock.lockStore.Unlock()
	return mock.StoreFunc(ctx, review)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//
//	len(mockedReviewRepository.StoreCalls())
func (mock *ReviewRepositoryMock) StoreCalls() []struct {
	Ctx    context.Context
	Review *entity.Review
} {
	var calls []struct {
		Ctx    context.Context
		Review *entity.Review
	}
	mock.lockStore.RLock()
	calls = mock.calls.Store
	mock.lockStore.RUnlock()
	return calls
}

// Ensure, that AlbumRepositoryMock does implement AlbumRepository.
// If this is not the case, regenerate this file with moq.
var _ AlbumRepository = &AlbumRepositoryMock{}

// AlbumRepositoryMock is a mock implementation of AlbumRepository.
//
//	func TestSomethingThatUsesAlbumRepository(t *testing.T) {
//
//		// make and configure a mocked AlbumRepository
//		mockedAlbumRepository := &AlbumRepositoryMock{
//			GetByIdFunc: func(ctx context.Context, albumId string) (*entity.Album, error) {
//				panic("mock out the GetById method")
//			},
//		}
//
//		// use mockedAlbumRepository in code that requires AlbumRepository
//		// and then make assertions.
//
//	}
type AlbumRepositoryMock struct {
	// GetByIdFunc mocks the GetById method.
	GetByIdFunc func(ctx context.Context, albumId string) (*entity.Album, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetById holds details about calls to the GetById method.
		GetById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlbumId is the albumId argument value.
			AlbumId string
		}
	}
	lockGetById sync.RWMutex
}

// GetById calls GetByIdFunc.
func (mock *AlbumRepositoryMock) GetById(ctx context.Context, albumId string) (*entity.Album, error) {
	if mock.GetByIdFunc == nil {
		panic("AlbumRepositoryMock.GetByIdFunc: method is nil but AlbumRepository.GetById was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		AlbumId string
	}{
		Ctx:     ctx,
		AlbumId: albumId,
	}
	mock.lockGetById.Lock()
	mock.calls.GetById = append(mock.calls.GetById, callInfo)
	mock.lockGetById.Unlock()
	return mock.GetByIdFunc(ctx, albumId)
}

// GetByIdCalls gets all the calls that were made to GetById.
// Check the length with:
//
//	len(mockedAlbumRepository.GetByIdCalls())
func (mock *AlbumRepositoryMock) GetByIdCalls() []struct {
	Ctx     context.Context
	AlbumId string
} {
	var calls []struct {
		Ctx     context.Context
		AlbumId string
	}
	mock.lockGetById.RLock()
	calls = mock.calls.GetById
	mock.lockGetById.RUnlock()
	return calls
}
