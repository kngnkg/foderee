// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package usecase

import (
	"context"
	"github.com/kngnkg/tunetrail/api/entity"
	"sync"
)

// Ensure, that ReviewRepositoryMock does implement ReviewRepository.
// If this is not the case, regenerate this file with moq.
var _ ReviewRepository = &ReviewRepositoryMock{}

// ReviewRepositoryMock is a mock implementation of ReviewRepository.
//
//	func TestSomethingThatUsesReviewRepository(t *testing.T) {
//
//		// make and configure a mocked ReviewRepository
//		mockedReviewRepository := &ReviewRepositoryMock{
//			GetByAuthorIdFunc: func(ctx context.Context, authorId entity.UserId, nextCursor string, limit int) ([]*entity.Review, string, error) {
//				panic("mock out the GetByAuthorId method")
//			},
//			GetByIdFunc: func(ctx context.Context, reviewId string) (*entity.Review, error) {
//				panic("mock out the GetById method")
//			},
//			StoreFunc: func(ctx context.Context, review *entity.Review) (*entity.Review, error) {
//				panic("mock out the Store method")
//			},
//		}
//
//		// use mockedReviewRepository in code that requires ReviewRepository
//		// and then make assertions.
//
//	}
type ReviewRepositoryMock struct {
	// GetByAuthorIdFunc mocks the GetByAuthorId method.
	GetByAuthorIdFunc func(ctx context.Context, authorId entity.UserId, nextCursor string, limit int) ([]*entity.Review, string, error)

	// GetByIdFunc mocks the GetById method.
	GetByIdFunc func(ctx context.Context, reviewId string) (*entity.Review, error)

	// StoreFunc mocks the Store method.
	StoreFunc func(ctx context.Context, review *entity.Review) (*entity.Review, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetByAuthorId holds details about calls to the GetByAuthorId method.
		GetByAuthorId []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AuthorId is the authorId argument value.
			AuthorId entity.UserId
			// NextCursor is the nextCursor argument value.
			NextCursor string
			// Limit is the limit argument value.
			Limit int
		}
		// GetById holds details about calls to the GetById method.
		GetById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReviewId is the reviewId argument value.
			ReviewId string
		}
		// Store holds details about calls to the Store method.
		Store []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Review is the review argument value.
			Review *entity.Review
		}
	}
	lockGetByAuthorId sync.RWMutex
	lockGetById       sync.RWMutex
	lockStore         sync.RWMutex
}

// GetByAuthorId calls GetByAuthorIdFunc.
func (mock *ReviewRepositoryMock) GetByAuthorId(ctx context.Context, authorId entity.UserId, nextCursor string, limit int) ([]*entity.Review, string, error) {
	if mock.GetByAuthorIdFunc == nil {
		panic("ReviewRepositoryMock.GetByAuthorIdFunc: method is nil but ReviewRepository.GetByAuthorId was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		AuthorId   entity.UserId
		NextCursor string
		Limit      int
	}{
		Ctx:        ctx,
		AuthorId:   authorId,
		NextCursor: nextCursor,
		Limit:      limit,
	}
	mock.lockGetByAuthorId.Lock()
	mock.calls.GetByAuthorId = append(mock.calls.GetByAuthorId, callInfo)
	mock.lockGetByAuthorId.Unlock()
	return mock.GetByAuthorIdFunc(ctx, authorId, nextCursor, limit)
}

// GetByAuthorIdCalls gets all the calls that were made to GetByAuthorId.
// Check the length with:
//
//	len(mockedReviewRepository.GetByAuthorIdCalls())
func (mock *ReviewRepositoryMock) GetByAuthorIdCalls() []struct {
	Ctx        context.Context
	AuthorId   entity.UserId
	NextCursor string
	Limit      int
} {
	var calls []struct {
		Ctx        context.Context
		AuthorId   entity.UserId
		NextCursor string
		Limit      int
	}
	mock.lockGetByAuthorId.RLock()
	calls = mock.calls.GetByAuthorId
	mock.lockGetByAuthorId.RUnlock()
	return calls
}

// GetById calls GetByIdFunc.
func (mock *ReviewRepositoryMock) GetById(ctx context.Context, reviewId string) (*entity.Review, error) {
	if mock.GetByIdFunc == nil {
		panic("ReviewRepositoryMock.GetByIdFunc: method is nil but ReviewRepository.GetById was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		ReviewId string
	}{
		Ctx:      ctx,
		ReviewId: reviewId,
	}
	mock.lockGetById.Lock()
	mock.calls.GetById = append(mock.calls.GetById, callInfo)
	mock.lockGetById.Unlock()
	return mock.GetByIdFunc(ctx, reviewId)
}

// GetByIdCalls gets all the calls that were made to GetById.
// Check the length with:
//
//	len(mockedReviewRepository.GetByIdCalls())
func (mock *ReviewRepositoryMock) GetByIdCalls() []struct {
	Ctx      context.Context
	ReviewId string
} {
	var calls []struct {
		Ctx      context.Context
		ReviewId string
	}
	mock.lockGetById.RLock()
	calls = mock.calls.GetById
	mock.lockGetById.RUnlock()
	return calls
}

// Store calls StoreFunc.
func (mock *ReviewRepositoryMock) Store(ctx context.Context, review *entity.Review) (*entity.Review, error) {
	if mock.StoreFunc == nil {
		panic("ReviewRepositoryMock.StoreFunc: method is nil but ReviewRepository.Store was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Review *entity.Review
	}{
		Ctx:    ctx,
		Review: review,
	}
	mock.lockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	mock.lockStore.Unlock()
	return mock.StoreFunc(ctx, review)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//
//	len(mockedReviewRepository.StoreCalls())
func (mock *ReviewRepositoryMock) StoreCalls() []struct {
	Ctx    context.Context
	Review *entity.Review
} {
	var calls []struct {
		Ctx    context.Context
		Review *entity.Review
	}
	mock.lockStore.RLock()
	calls = mock.calls.Store
	mock.lockStore.RUnlock()
	return calls
}

// Ensure, that AlbumRepositoryMock does implement AlbumRepository.
// If this is not the case, regenerate this file with moq.
var _ AlbumRepository = &AlbumRepositoryMock{}

// AlbumRepositoryMock is a mock implementation of AlbumRepository.
//
//	func TestSomethingThatUsesAlbumRepository(t *testing.T) {
//
//		// make and configure a mocked AlbumRepository
//		mockedAlbumRepository := &AlbumRepositoryMock{
//			GetByIdFunc: func(ctx context.Context, albumId string) (*entity.Album, error) {
//				panic("mock out the GetById method")
//			},
//			GetByIdsFunc: func(ctx context.Context, albumIds []string) ([]*entity.Album, error) {
//				panic("mock out the GetByIds method")
//			},
//		}
//
//		// use mockedAlbumRepository in code that requires AlbumRepository
//		// and then make assertions.
//
//	}
type AlbumRepositoryMock struct {
	// GetByIdFunc mocks the GetById method.
	GetByIdFunc func(ctx context.Context, albumId string) (*entity.Album, error)

	// GetByIdsFunc mocks the GetByIds method.
	GetByIdsFunc func(ctx context.Context, albumIds []string) ([]*entity.Album, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetById holds details about calls to the GetById method.
		GetById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlbumId is the albumId argument value.
			AlbumId string
		}
		// GetByIds holds details about calls to the GetByIds method.
		GetByIds []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlbumIds is the albumIds argument value.
			AlbumIds []string
		}
	}
	lockGetById  sync.RWMutex
	lockGetByIds sync.RWMutex
}

// GetById calls GetByIdFunc.
func (mock *AlbumRepositoryMock) GetById(ctx context.Context, albumId string) (*entity.Album, error) {
	if mock.GetByIdFunc == nil {
		panic("AlbumRepositoryMock.GetByIdFunc: method is nil but AlbumRepository.GetById was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		AlbumId string
	}{
		Ctx:     ctx,
		AlbumId: albumId,
	}
	mock.lockGetById.Lock()
	mock.calls.GetById = append(mock.calls.GetById, callInfo)
	mock.lockGetById.Unlock()
	return mock.GetByIdFunc(ctx, albumId)
}

// GetByIdCalls gets all the calls that were made to GetById.
// Check the length with:
//
//	len(mockedAlbumRepository.GetByIdCalls())
func (mock *AlbumRepositoryMock) GetByIdCalls() []struct {
	Ctx     context.Context
	AlbumId string
} {
	var calls []struct {
		Ctx     context.Context
		AlbumId string
	}
	mock.lockGetById.RLock()
	calls = mock.calls.GetById
	mock.lockGetById.RUnlock()
	return calls
}

// GetByIds calls GetByIdsFunc.
func (mock *AlbumRepositoryMock) GetByIds(ctx context.Context, albumIds []string) ([]*entity.Album, error) {
	if mock.GetByIdsFunc == nil {
		panic("AlbumRepositoryMock.GetByIdsFunc: method is nil but AlbumRepository.GetByIds was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		AlbumIds []string
	}{
		Ctx:      ctx,
		AlbumIds: albumIds,
	}
	mock.lockGetByIds.Lock()
	mock.calls.GetByIds = append(mock.calls.GetByIds, callInfo)
	mock.lockGetByIds.Unlock()
	return mock.GetByIdsFunc(ctx, albumIds)
}

// GetByIdsCalls gets all the calls that were made to GetByIds.
// Check the length with:
//
//	len(mockedAlbumRepository.GetByIdsCalls())
func (mock *AlbumRepositoryMock) GetByIdsCalls() []struct {
	Ctx      context.Context
	AlbumIds []string
} {
	var calls []struct {
		Ctx      context.Context
		AlbumIds []string
	}
	mock.lockGetByIds.RLock()
	calls = mock.calls.GetByIds
	mock.lockGetByIds.RUnlock()
	return calls
}

// Ensure, that UserRepositoryMock does implement UserRepository.
// If this is not the case, regenerate this file with moq.
var _ UserRepository = &UserRepositoryMock{}

// UserRepositoryMock is a mock implementation of UserRepository.
//
//	func TestSomethingThatUsesUserRepository(t *testing.T) {
//
//		// make and configure a mocked UserRepository
//		mockedUserRepository := &UserRepositoryMock{
//			GetByIdFunc: func(ctx context.Context, userId entity.UserId) (*entity.User, error) {
//				panic("mock out the GetById method")
//			},
//		}
//
//		// use mockedUserRepository in code that requires UserRepository
//		// and then make assertions.
//
//	}
type UserRepositoryMock struct {
	// GetByIdFunc mocks the GetById method.
	GetByIdFunc func(ctx context.Context, userId entity.UserId) (*entity.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetById holds details about calls to the GetById method.
		GetById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserId is the userId argument value.
			UserId entity.UserId
		}
	}
	lockGetById sync.RWMutex
}

// GetById calls GetByIdFunc.
func (mock *UserRepositoryMock) GetById(ctx context.Context, userId entity.UserId) (*entity.User, error) {
	if mock.GetByIdFunc == nil {
		panic("UserRepositoryMock.GetByIdFunc: method is nil but UserRepository.GetById was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserId entity.UserId
	}{
		Ctx:    ctx,
		UserId: userId,
	}
	mock.lockGetById.Lock()
	mock.calls.GetById = append(mock.calls.GetById, callInfo)
	mock.lockGetById.Unlock()
	return mock.GetByIdFunc(ctx, userId)
}

// GetByIdCalls gets all the calls that were made to GetById.
// Check the length with:
//
//	len(mockedUserRepository.GetByIdCalls())
func (mock *UserRepositoryMock) GetByIdCalls() []struct {
	Ctx    context.Context
	UserId entity.UserId
} {
	var calls []struct {
		Ctx    context.Context
		UserId entity.UserId
	}
	mock.lockGetById.RLock()
	calls = mock.calls.GetById
	mock.lockGetById.RUnlock()
	return calls
}
