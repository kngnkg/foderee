// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package usecase

import (
	"context"
	"github.com/kngnkg/tunetrail/backend/entity"
	"github.com/kngnkg/tunetrail/backend/infra/repository"
	"sync"
)

// Ensure, that ReviewRepositoryMock does implement ReviewRepository.
// If this is not the case, regenerate this file with moq.
var _ ReviewRepository = &ReviewRepositoryMock{}

// ReviewRepositoryMock is a mock implementation of ReviewRepository.
//
//	func TestSomethingThatUsesReviewRepository(t *testing.T) {
//
//		// make and configure a mocked ReviewRepository
//		mockedReviewRepository := &ReviewRepositoryMock{
//			DeleteReviewByIdFunc: func(ctx context.Context, db repository.Executor, reviewId string) error {
//				panic("mock out the DeleteReviewById method")
//			},
//			GetReviewByAuthorIdFunc: func(ctx context.Context, db repository.Executor, authorId entity.UserId, nextCursor string, limit int) ([]*entity.Review, string, error) {
//				panic("mock out the GetReviewByAuthorId method")
//			},
//			GetReviewByIdFunc: func(ctx context.Context, db repository.Executor, reviewId string) (*entity.Review, error) {
//				panic("mock out the GetReviewById method")
//			},
//			StoreReviewFunc: func(ctx context.Context, db repository.Executor, review *entity.Review) (*entity.Review, error) {
//				panic("mock out the StoreReview method")
//			},
//			UpdateReviewFunc: func(ctx context.Context, db repository.Executor, review *entity.Review) (*entity.Review, error) {
//				panic("mock out the UpdateReview method")
//			},
//		}
//
//		// use mockedReviewRepository in code that requires ReviewRepository
//		// and then make assertions.
//
//	}
type ReviewRepositoryMock struct {
	// DeleteReviewByIdFunc mocks the DeleteReviewById method.
	DeleteReviewByIdFunc func(ctx context.Context, db repository.Executor, reviewId string) error

	// GetReviewByAuthorIdFunc mocks the GetReviewByAuthorId method.
	GetReviewByAuthorIdFunc func(ctx context.Context, db repository.Executor, authorId entity.UserId, nextCursor string, limit int) ([]*entity.Review, string, error)

	// GetReviewByIdFunc mocks the GetReviewById method.
	GetReviewByIdFunc func(ctx context.Context, db repository.Executor, reviewId string) (*entity.Review, error)

	// StoreReviewFunc mocks the StoreReview method.
	StoreReviewFunc func(ctx context.Context, db repository.Executor, review *entity.Review) (*entity.Review, error)

	// UpdateReviewFunc mocks the UpdateReview method.
	UpdateReviewFunc func(ctx context.Context, db repository.Executor, review *entity.Review) (*entity.Review, error)

	// calls tracks calls to the methods.
	calls struct {
		// DeleteReviewById holds details about calls to the DeleteReviewById method.
		DeleteReviewById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// ReviewId is the reviewId argument value.
			ReviewId string
		}
		// GetReviewByAuthorId holds details about calls to the GetReviewByAuthorId method.
		GetReviewByAuthorId []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// AuthorId is the authorId argument value.
			AuthorId entity.UserId
			// NextCursor is the nextCursor argument value.
			NextCursor string
			// Limit is the limit argument value.
			Limit int
		}
		// GetReviewById holds details about calls to the GetReviewById method.
		GetReviewById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// ReviewId is the reviewId argument value.
			ReviewId string
		}
		// StoreReview holds details about calls to the StoreReview method.
		StoreReview []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// Review is the review argument value.
			Review *entity.Review
		}
		// UpdateReview holds details about calls to the UpdateReview method.
		UpdateReview []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// Review is the review argument value.
			Review *entity.Review
		}
	}
	lockDeleteReviewById    sync.RWMutex
	lockGetReviewByAuthorId sync.RWMutex
	lockGetReviewById       sync.RWMutex
	lockStoreReview         sync.RWMutex
	lockUpdateReview        sync.RWMutex
}

// DeleteReviewById calls DeleteReviewByIdFunc.
func (mock *ReviewRepositoryMock) DeleteReviewById(ctx context.Context, db repository.Executor, reviewId string) error {
	if mock.DeleteReviewByIdFunc == nil {
		panic("ReviewRepositoryMock.DeleteReviewByIdFunc: method is nil but ReviewRepository.DeleteReviewById was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Db       repository.Executor
		ReviewId string
	}{
		Ctx:      ctx,
		Db:       db,
		ReviewId: reviewId,
	}
	mock.lockDeleteReviewById.Lock()
	mock.calls.DeleteReviewById = append(mock.calls.DeleteReviewById, callInfo)
	mock.lockDeleteReviewById.Unlock()
	return mock.DeleteReviewByIdFunc(ctx, db, reviewId)
}

// DeleteReviewByIdCalls gets all the calls that were made to DeleteReviewById.
// Check the length with:
//
//	len(mockedReviewRepository.DeleteReviewByIdCalls())
func (mock *ReviewRepositoryMock) DeleteReviewByIdCalls() []struct {
	Ctx      context.Context
	Db       repository.Executor
	ReviewId string
} {
	var calls []struct {
		Ctx      context.Context
		Db       repository.Executor
		ReviewId string
	}
	mock.lockDeleteReviewById.RLock()
	calls = mock.calls.DeleteReviewById
	mock.lockDeleteReviewById.RUnlock()
	return calls
}

// GetReviewByAuthorId calls GetReviewByAuthorIdFunc.
func (mock *ReviewRepositoryMock) GetReviewByAuthorId(ctx context.Context, db repository.Executor, authorId entity.UserId, nextCursor string, limit int) ([]*entity.Review, string, error) {
	if mock.GetReviewByAuthorIdFunc == nil {
		panic("ReviewRepositoryMock.GetReviewByAuthorIdFunc: method is nil but ReviewRepository.GetReviewByAuthorId was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Db         repository.Executor
		AuthorId   entity.UserId
		NextCursor string
		Limit      int
	}{
		Ctx:        ctx,
		Db:         db,
		AuthorId:   authorId,
		NextCursor: nextCursor,
		Limit:      limit,
	}
	mock.lockGetReviewByAuthorId.Lock()
	mock.calls.GetReviewByAuthorId = append(mock.calls.GetReviewByAuthorId, callInfo)
	mock.lockGetReviewByAuthorId.Unlock()
	return mock.GetReviewByAuthorIdFunc(ctx, db, authorId, nextCursor, limit)
}

// GetReviewByAuthorIdCalls gets all the calls that were made to GetReviewByAuthorId.
// Check the length with:
//
//	len(mockedReviewRepository.GetReviewByAuthorIdCalls())
func (mock *ReviewRepositoryMock) GetReviewByAuthorIdCalls() []struct {
	Ctx        context.Context
	Db         repository.Executor
	AuthorId   entity.UserId
	NextCursor string
	Limit      int
} {
	var calls []struct {
		Ctx        context.Context
		Db         repository.Executor
		AuthorId   entity.UserId
		NextCursor string
		Limit      int
	}
	mock.lockGetReviewByAuthorId.RLock()
	calls = mock.calls.GetReviewByAuthorId
	mock.lockGetReviewByAuthorId.RUnlock()
	return calls
}

// GetReviewById calls GetReviewByIdFunc.
func (mock *ReviewRepositoryMock) GetReviewById(ctx context.Context, db repository.Executor, reviewId string) (*entity.Review, error) {
	if mock.GetReviewByIdFunc == nil {
		panic("ReviewRepositoryMock.GetReviewByIdFunc: method is nil but ReviewRepository.GetReviewById was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Db       repository.Executor
		ReviewId string
	}{
		Ctx:      ctx,
		Db:       db,
		ReviewId: reviewId,
	}
	mock.lockGetReviewById.Lock()
	mock.calls.GetReviewById = append(mock.calls.GetReviewById, callInfo)
	mock.lockGetReviewById.Unlock()
	return mock.GetReviewByIdFunc(ctx, db, reviewId)
}

// GetReviewByIdCalls gets all the calls that were made to GetReviewById.
// Check the length with:
//
//	len(mockedReviewRepository.GetReviewByIdCalls())
func (mock *ReviewRepositoryMock) GetReviewByIdCalls() []struct {
	Ctx      context.Context
	Db       repository.Executor
	ReviewId string
} {
	var calls []struct {
		Ctx      context.Context
		Db       repository.Executor
		ReviewId string
	}
	mock.lockGetReviewById.RLock()
	calls = mock.calls.GetReviewById
	mock.lockGetReviewById.RUnlock()
	return calls
}

// StoreReview calls StoreReviewFunc.
func (mock *ReviewRepositoryMock) StoreReview(ctx context.Context, db repository.Executor, review *entity.Review) (*entity.Review, error) {
	if mock.StoreReviewFunc == nil {
		panic("ReviewRepositoryMock.StoreReviewFunc: method is nil but ReviewRepository.StoreReview was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     repository.Executor
		Review *entity.Review
	}{
		Ctx:    ctx,
		Db:     db,
		Review: review,
	}
	mock.lockStoreReview.Lock()
	mock.calls.StoreReview = append(mock.calls.StoreReview, callInfo)
	mock.lockStoreReview.Unlock()
	return mock.StoreReviewFunc(ctx, db, review)
}

// StoreReviewCalls gets all the calls that were made to StoreReview.
// Check the length with:
//
//	len(mockedReviewRepository.StoreReviewCalls())
func (mock *ReviewRepositoryMock) StoreReviewCalls() []struct {
	Ctx    context.Context
	Db     repository.Executor
	Review *entity.Review
} {
	var calls []struct {
		Ctx    context.Context
		Db     repository.Executor
		Review *entity.Review
	}
	mock.lockStoreReview.RLock()
	calls = mock.calls.StoreReview
	mock.lockStoreReview.RUnlock()
	return calls
}

// UpdateReview calls UpdateReviewFunc.
func (mock *ReviewRepositoryMock) UpdateReview(ctx context.Context, db repository.Executor, review *entity.Review) (*entity.Review, error) {
	if mock.UpdateReviewFunc == nil {
		panic("ReviewRepositoryMock.UpdateReviewFunc: method is nil but ReviewRepository.UpdateReview was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     repository.Executor
		Review *entity.Review
	}{
		Ctx:    ctx,
		Db:     db,
		Review: review,
	}
	mock.lockUpdateReview.Lock()
	mock.calls.UpdateReview = append(mock.calls.UpdateReview, callInfo)
	mock.lockUpdateReview.Unlock()
	return mock.UpdateReviewFunc(ctx, db, review)
}

// UpdateReviewCalls gets all the calls that were made to UpdateReview.
// Check the length with:
//
//	len(mockedReviewRepository.UpdateReviewCalls())
func (mock *ReviewRepositoryMock) UpdateReviewCalls() []struct {
	Ctx    context.Context
	Db     repository.Executor
	Review *entity.Review
} {
	var calls []struct {
		Ctx    context.Context
		Db     repository.Executor
		Review *entity.Review
	}
	mock.lockUpdateReview.RLock()
	calls = mock.calls.UpdateReview
	mock.lockUpdateReview.RUnlock()
	return calls
}

// Ensure, that AlbumRepositoryMock does implement AlbumRepository.
// If this is not the case, regenerate this file with moq.
var _ AlbumRepository = &AlbumRepositoryMock{}

// AlbumRepositoryMock is a mock implementation of AlbumRepository.
//
//	func TestSomethingThatUsesAlbumRepository(t *testing.T) {
//
//		// make and configure a mocked AlbumRepository
//		mockedAlbumRepository := &AlbumRepositoryMock{
//			GetAlbumByIdFunc: func(ctx context.Context, albumId string) (*entity.Album, error) {
//				panic("mock out the GetAlbumById method")
//			},
//			GetAlbumByIdsFunc: func(ctx context.Context, albumIds []string) ([]*entity.Album, error) {
//				panic("mock out the GetAlbumByIds method")
//			},
//		}
//
//		// use mockedAlbumRepository in code that requires AlbumRepository
//		// and then make assertions.
//
//	}
type AlbumRepositoryMock struct {
	// GetAlbumByIdFunc mocks the GetAlbumById method.
	GetAlbumByIdFunc func(ctx context.Context, albumId string) (*entity.Album, error)

	// GetAlbumByIdsFunc mocks the GetAlbumByIds method.
	GetAlbumByIdsFunc func(ctx context.Context, albumIds []string) ([]*entity.Album, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetAlbumById holds details about calls to the GetAlbumById method.
		GetAlbumById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlbumId is the albumId argument value.
			AlbumId string
		}
		// GetAlbumByIds holds details about calls to the GetAlbumByIds method.
		GetAlbumByIds []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlbumIds is the albumIds argument value.
			AlbumIds []string
		}
	}
	lockGetAlbumById  sync.RWMutex
	lockGetAlbumByIds sync.RWMutex
}

// GetAlbumById calls GetAlbumByIdFunc.
func (mock *AlbumRepositoryMock) GetAlbumById(ctx context.Context, albumId string) (*entity.Album, error) {
	if mock.GetAlbumByIdFunc == nil {
		panic("AlbumRepositoryMock.GetAlbumByIdFunc: method is nil but AlbumRepository.GetAlbumById was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		AlbumId string
	}{
		Ctx:     ctx,
		AlbumId: albumId,
	}
	mock.lockGetAlbumById.Lock()
	mock.calls.GetAlbumById = append(mock.calls.GetAlbumById, callInfo)
	mock.lockGetAlbumById.Unlock()
	return mock.GetAlbumByIdFunc(ctx, albumId)
}

// GetAlbumByIdCalls gets all the calls that were made to GetAlbumById.
// Check the length with:
//
//	len(mockedAlbumRepository.GetAlbumByIdCalls())
func (mock *AlbumRepositoryMock) GetAlbumByIdCalls() []struct {
	Ctx     context.Context
	AlbumId string
} {
	var calls []struct {
		Ctx     context.Context
		AlbumId string
	}
	mock.lockGetAlbumById.RLock()
	calls = mock.calls.GetAlbumById
	mock.lockGetAlbumById.RUnlock()
	return calls
}

// GetAlbumByIds calls GetAlbumByIdsFunc.
func (mock *AlbumRepositoryMock) GetAlbumByIds(ctx context.Context, albumIds []string) ([]*entity.Album, error) {
	if mock.GetAlbumByIdsFunc == nil {
		panic("AlbumRepositoryMock.GetAlbumByIdsFunc: method is nil but AlbumRepository.GetAlbumByIds was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		AlbumIds []string
	}{
		Ctx:      ctx,
		AlbumIds: albumIds,
	}
	mock.lockGetAlbumByIds.Lock()
	mock.calls.GetAlbumByIds = append(mock.calls.GetAlbumByIds, callInfo)
	mock.lockGetAlbumByIds.Unlock()
	return mock.GetAlbumByIdsFunc(ctx, albumIds)
}

// GetAlbumByIdsCalls gets all the calls that were made to GetAlbumByIds.
// Check the length with:
//
//	len(mockedAlbumRepository.GetAlbumByIdsCalls())
func (mock *AlbumRepositoryMock) GetAlbumByIdsCalls() []struct {
	Ctx      context.Context
	AlbumIds []string
} {
	var calls []struct {
		Ctx      context.Context
		AlbumIds []string
	}
	mock.lockGetAlbumByIds.RLock()
	calls = mock.calls.GetAlbumByIds
	mock.lockGetAlbumByIds.RUnlock()
	return calls
}

// Ensure, that UserRepositoryMock does implement UserRepository.
// If this is not the case, regenerate this file with moq.
var _ UserRepository = &UserRepositoryMock{}

// UserRepositoryMock is a mock implementation of UserRepository.
//
//	func TestSomethingThatUsesUserRepository(t *testing.T) {
//
//		// make and configure a mocked UserRepository
//		mockedUserRepository := &UserRepositoryMock{
//			GetUserByIdFunc: func(ctx context.Context, db repository.Executor, userId entity.UserId) (*entity.User, error) {
//				panic("mock out the GetUserById method")
//			},
//			GetUserByIdsFunc: func(ctx context.Context, db repository.Executor, userIds []entity.UserId) ([]*entity.User, error) {
//				panic("mock out the GetUserByIds method")
//			},
//		}
//
//		// use mockedUserRepository in code that requires UserRepository
//		// and then make assertions.
//
//	}
type UserRepositoryMock struct {
	// GetUserByIdFunc mocks the GetUserById method.
	GetUserByIdFunc func(ctx context.Context, db repository.Executor, userId entity.UserId) (*entity.User, error)

	// GetUserByIdsFunc mocks the GetUserByIds method.
	GetUserByIdsFunc func(ctx context.Context, db repository.Executor, userIds []entity.UserId) ([]*entity.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetUserById holds details about calls to the GetUserById method.
		GetUserById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// UserId is the userId argument value.
			UserId entity.UserId
		}
		// GetUserByIds holds details about calls to the GetUserByIds method.
		GetUserByIds []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// UserIds is the userIds argument value.
			UserIds []entity.UserId
		}
	}
	lockGetUserById  sync.RWMutex
	lockGetUserByIds sync.RWMutex
}

// GetUserById calls GetUserByIdFunc.
func (mock *UserRepositoryMock) GetUserById(ctx context.Context, db repository.Executor, userId entity.UserId) (*entity.User, error) {
	if mock.GetUserByIdFunc == nil {
		panic("UserRepositoryMock.GetUserByIdFunc: method is nil but UserRepository.GetUserById was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     repository.Executor
		UserId entity.UserId
	}{
		Ctx:    ctx,
		Db:     db,
		UserId: userId,
	}
	mock.lockGetUserById.Lock()
	mock.calls.GetUserById = append(mock.calls.GetUserById, callInfo)
	mock.lockGetUserById.Unlock()
	return mock.GetUserByIdFunc(ctx, db, userId)
}

// GetUserByIdCalls gets all the calls that were made to GetUserById.
// Check the length with:
//
//	len(mockedUserRepository.GetUserByIdCalls())
func (mock *UserRepositoryMock) GetUserByIdCalls() []struct {
	Ctx    context.Context
	Db     repository.Executor
	UserId entity.UserId
} {
	var calls []struct {
		Ctx    context.Context
		Db     repository.Executor
		UserId entity.UserId
	}
	mock.lockGetUserById.RLock()
	calls = mock.calls.GetUserById
	mock.lockGetUserById.RUnlock()
	return calls
}

// GetUserByIds calls GetUserByIdsFunc.
func (mock *UserRepositoryMock) GetUserByIds(ctx context.Context, db repository.Executor, userIds []entity.UserId) ([]*entity.User, error) {
	if mock.GetUserByIdsFunc == nil {
		panic("UserRepositoryMock.GetUserByIdsFunc: method is nil but UserRepository.GetUserByIds was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Db      repository.Executor
		UserIds []entity.UserId
	}{
		Ctx:     ctx,
		Db:      db,
		UserIds: userIds,
	}
	mock.lockGetUserByIds.Lock()
	mock.calls.GetUserByIds = append(mock.calls.GetUserByIds, callInfo)
	mock.lockGetUserByIds.Unlock()
	return mock.GetUserByIdsFunc(ctx, db, userIds)
}

// GetUserByIdsCalls gets all the calls that were made to GetUserByIds.
// Check the length with:
//
//	len(mockedUserRepository.GetUserByIdsCalls())
func (mock *UserRepositoryMock) GetUserByIdsCalls() []struct {
	Ctx     context.Context
	Db      repository.Executor
	UserIds []entity.UserId
} {
	var calls []struct {
		Ctx     context.Context
		Db      repository.Executor
		UserIds []entity.UserId
	}
	mock.lockGetUserByIds.RLock()
	calls = mock.calls.GetUserByIds
	mock.lockGetUserByIds.RUnlock()
	return calls
}

// Ensure, that UserFollowRepositoryMock does implement UserFollowRepository.
// If this is not the case, regenerate this file with moq.
var _ UserFollowRepository = &UserFollowRepositoryMock{}

// UserFollowRepositoryMock is a mock implementation of UserFollowRepository.
//
//	func TestSomethingThatUsesUserFollowRepository(t *testing.T) {
//
//		// make and configure a mocked UserFollowRepository
//		mockedUserFollowRepository := &UserFollowRepositoryMock{
//			DeleteUserFollowFunc: func(ctx context.Context, db repository.Executor, userFollow *entity.UserFollow) error {
//				panic("mock out the DeleteUserFollow method")
//			},
//			GetUserFollowByUserIdsFunc: func(ctx context.Context, db repository.Executor, sourceId entity.UserId, targetId entity.UserId) ([]*entity.UserFollow, error) {
//				panic("mock out the GetUserFollowByUserIds method")
//			},
//			IsFollowedFunc: func(ctx context.Context, db repository.Executor, sourceId entity.UserId, targetId entity.UserId) (bool, error) {
//				panic("mock out the IsFollowed method")
//			},
//			IsFollowingFunc: func(ctx context.Context, db repository.Executor, sourceId entity.UserId, targetId entity.UserId) (bool, error) {
//				panic("mock out the IsFollowing method")
//			},
//			StoreUserFollowFunc: func(ctx context.Context, db repository.Executor, userFollow *entity.UserFollow) (*entity.UserFollow, error) {
//				panic("mock out the StoreUserFollow method")
//			},
//		}
//
//		// use mockedUserFollowRepository in code that requires UserFollowRepository
//		// and then make assertions.
//
//	}
type UserFollowRepositoryMock struct {
	// DeleteUserFollowFunc mocks the DeleteUserFollow method.
	DeleteUserFollowFunc func(ctx context.Context, db repository.Executor, userFollow *entity.UserFollow) error

	// GetUserFollowByUserIdsFunc mocks the GetUserFollowByUserIds method.
	GetUserFollowByUserIdsFunc func(ctx context.Context, db repository.Executor, sourceId entity.UserId, targetId entity.UserId) ([]*entity.UserFollow, error)

	// IsFollowedFunc mocks the IsFollowed method.
	IsFollowedFunc func(ctx context.Context, db repository.Executor, sourceId entity.UserId, targetId entity.UserId) (bool, error)

	// IsFollowingFunc mocks the IsFollowing method.
	IsFollowingFunc func(ctx context.Context, db repository.Executor, sourceId entity.UserId, targetId entity.UserId) (bool, error)

	// StoreUserFollowFunc mocks the StoreUserFollow method.
	StoreUserFollowFunc func(ctx context.Context, db repository.Executor, userFollow *entity.UserFollow) (*entity.UserFollow, error)

	// calls tracks calls to the methods.
	calls struct {
		// DeleteUserFollow holds details about calls to the DeleteUserFollow method.
		DeleteUserFollow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// UserFollow is the userFollow argument value.
			UserFollow *entity.UserFollow
		}
		// GetUserFollowByUserIds holds details about calls to the GetUserFollowByUserIds method.
		GetUserFollowByUserIds []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// SourceId is the sourceId argument value.
			SourceId entity.UserId
			// TargetId is the targetId argument value.
			TargetId entity.UserId
		}
		// IsFollowed holds details about calls to the IsFollowed method.
		IsFollowed []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// SourceId is the sourceId argument value.
			SourceId entity.UserId
			// TargetId is the targetId argument value.
			TargetId entity.UserId
		}
		// IsFollowing holds details about calls to the IsFollowing method.
		IsFollowing []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// SourceId is the sourceId argument value.
			SourceId entity.UserId
			// TargetId is the targetId argument value.
			TargetId entity.UserId
		}
		// StoreUserFollow holds details about calls to the StoreUserFollow method.
		StoreUserFollow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// UserFollow is the userFollow argument value.
			UserFollow *entity.UserFollow
		}
	}
	lockDeleteUserFollow       sync.RWMutex
	lockGetUserFollowByUserIds sync.RWMutex
	lockIsFollowed             sync.RWMutex
	lockIsFollowing            sync.RWMutex
	lockStoreUserFollow        sync.RWMutex
}

// DeleteUserFollow calls DeleteUserFollowFunc.
func (mock *UserFollowRepositoryMock) DeleteUserFollow(ctx context.Context, db repository.Executor, userFollow *entity.UserFollow) error {
	if mock.DeleteUserFollowFunc == nil {
		panic("UserFollowRepositoryMock.DeleteUserFollowFunc: method is nil but UserFollowRepository.DeleteUserFollow was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Db         repository.Executor
		UserFollow *entity.UserFollow
	}{
		Ctx:        ctx,
		Db:         db,
		UserFollow: userFollow,
	}
	mock.lockDeleteUserFollow.Lock()
	mock.calls.DeleteUserFollow = append(mock.calls.DeleteUserFollow, callInfo)
	mock.lockDeleteUserFollow.Unlock()
	return mock.DeleteUserFollowFunc(ctx, db, userFollow)
}

// DeleteUserFollowCalls gets all the calls that were made to DeleteUserFollow.
// Check the length with:
//
//	len(mockedUserFollowRepository.DeleteUserFollowCalls())
func (mock *UserFollowRepositoryMock) DeleteUserFollowCalls() []struct {
	Ctx        context.Context
	Db         repository.Executor
	UserFollow *entity.UserFollow
} {
	var calls []struct {
		Ctx        context.Context
		Db         repository.Executor
		UserFollow *entity.UserFollow
	}
	mock.lockDeleteUserFollow.RLock()
	calls = mock.calls.DeleteUserFollow
	mock.lockDeleteUserFollow.RUnlock()
	return calls
}

// GetUserFollowByUserIds calls GetUserFollowByUserIdsFunc.
func (mock *UserFollowRepositoryMock) GetUserFollowByUserIds(ctx context.Context, db repository.Executor, sourceId entity.UserId, targetId entity.UserId) ([]*entity.UserFollow, error) {
	if mock.GetUserFollowByUserIdsFunc == nil {
		panic("UserFollowRepositoryMock.GetUserFollowByUserIdsFunc: method is nil but UserFollowRepository.GetUserFollowByUserIds was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Db       repository.Executor
		SourceId entity.UserId
		TargetId entity.UserId
	}{
		Ctx:      ctx,
		Db:       db,
		SourceId: sourceId,
		TargetId: targetId,
	}
	mock.lockGetUserFollowByUserIds.Lock()
	mock.calls.GetUserFollowByUserIds = append(mock.calls.GetUserFollowByUserIds, callInfo)
	mock.lockGetUserFollowByUserIds.Unlock()
	return mock.GetUserFollowByUserIdsFunc(ctx, db, sourceId, targetId)
}

// GetUserFollowByUserIdsCalls gets all the calls that were made to GetUserFollowByUserIds.
// Check the length with:
//
//	len(mockedUserFollowRepository.GetUserFollowByUserIdsCalls())
func (mock *UserFollowRepositoryMock) GetUserFollowByUserIdsCalls() []struct {
	Ctx      context.Context
	Db       repository.Executor
	SourceId entity.UserId
	TargetId entity.UserId
} {
	var calls []struct {
		Ctx      context.Context
		Db       repository.Executor
		SourceId entity.UserId
		TargetId entity.UserId
	}
	mock.lockGetUserFollowByUserIds.RLock()
	calls = mock.calls.GetUserFollowByUserIds
	mock.lockGetUserFollowByUserIds.RUnlock()
	return calls
}

// IsFollowed calls IsFollowedFunc.
func (mock *UserFollowRepositoryMock) IsFollowed(ctx context.Context, db repository.Executor, sourceId entity.UserId, targetId entity.UserId) (bool, error) {
	if mock.IsFollowedFunc == nil {
		panic("UserFollowRepositoryMock.IsFollowedFunc: method is nil but UserFollowRepository.IsFollowed was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Db       repository.Executor
		SourceId entity.UserId
		TargetId entity.UserId
	}{
		Ctx:      ctx,
		Db:       db,
		SourceId: sourceId,
		TargetId: targetId,
	}
	mock.lockIsFollowed.Lock()
	mock.calls.IsFollowed = append(mock.calls.IsFollowed, callInfo)
	mock.lockIsFollowed.Unlock()
	return mock.IsFollowedFunc(ctx, db, sourceId, targetId)
}

// IsFollowedCalls gets all the calls that were made to IsFollowed.
// Check the length with:
//
//	len(mockedUserFollowRepository.IsFollowedCalls())
func (mock *UserFollowRepositoryMock) IsFollowedCalls() []struct {
	Ctx      context.Context
	Db       repository.Executor
	SourceId entity.UserId
	TargetId entity.UserId
} {
	var calls []struct {
		Ctx      context.Context
		Db       repository.Executor
		SourceId entity.UserId
		TargetId entity.UserId
	}
	mock.lockIsFollowed.RLock()
	calls = mock.calls.IsFollowed
	mock.lockIsFollowed.RUnlock()
	return calls
}

// IsFollowing calls IsFollowingFunc.
func (mock *UserFollowRepositoryMock) IsFollowing(ctx context.Context, db repository.Executor, sourceId entity.UserId, targetId entity.UserId) (bool, error) {
	if mock.IsFollowingFunc == nil {
		panic("UserFollowRepositoryMock.IsFollowingFunc: method is nil but UserFollowRepository.IsFollowing was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Db       repository.Executor
		SourceId entity.UserId
		TargetId entity.UserId
	}{
		Ctx:      ctx,
		Db:       db,
		SourceId: sourceId,
		TargetId: targetId,
	}
	mock.lockIsFollowing.Lock()
	mock.calls.IsFollowing = append(mock.calls.IsFollowing, callInfo)
	mock.lockIsFollowing.Unlock()
	return mock.IsFollowingFunc(ctx, db, sourceId, targetId)
}

// IsFollowingCalls gets all the calls that were made to IsFollowing.
// Check the length with:
//
//	len(mockedUserFollowRepository.IsFollowingCalls())
func (mock *UserFollowRepositoryMock) IsFollowingCalls() []struct {
	Ctx      context.Context
	Db       repository.Executor
	SourceId entity.UserId
	TargetId entity.UserId
} {
	var calls []struct {
		Ctx      context.Context
		Db       repository.Executor
		SourceId entity.UserId
		TargetId entity.UserId
	}
	mock.lockIsFollowing.RLock()
	calls = mock.calls.IsFollowing
	mock.lockIsFollowing.RUnlock()
	return calls
}

// StoreUserFollow calls StoreUserFollowFunc.
func (mock *UserFollowRepositoryMock) StoreUserFollow(ctx context.Context, db repository.Executor, userFollow *entity.UserFollow) (*entity.UserFollow, error) {
	if mock.StoreUserFollowFunc == nil {
		panic("UserFollowRepositoryMock.StoreUserFollowFunc: method is nil but UserFollowRepository.StoreUserFollow was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Db         repository.Executor
		UserFollow *entity.UserFollow
	}{
		Ctx:        ctx,
		Db:         db,
		UserFollow: userFollow,
	}
	mock.lockStoreUserFollow.Lock()
	mock.calls.StoreUserFollow = append(mock.calls.StoreUserFollow, callInfo)
	mock.lockStoreUserFollow.Unlock()
	return mock.StoreUserFollowFunc(ctx, db, userFollow)
}

// StoreUserFollowCalls gets all the calls that were made to StoreUserFollow.
// Check the length with:
//
//	len(mockedUserFollowRepository.StoreUserFollowCalls())
func (mock *UserFollowRepositoryMock) StoreUserFollowCalls() []struct {
	Ctx        context.Context
	Db         repository.Executor
	UserFollow *entity.UserFollow
} {
	var calls []struct {
		Ctx        context.Context
		Db         repository.Executor
		UserFollow *entity.UserFollow
	}
	mock.lockStoreUserFollow.RLock()
	calls = mock.calls.StoreUserFollow
	mock.lockStoreUserFollow.RUnlock()
	return calls
}
