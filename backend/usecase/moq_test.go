// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package usecase

import (
	"context"
	"github.com/kngnkg/tunetrail/backend/entity"
	"github.com/kngnkg/tunetrail/backend/infra/repository"
	"sync"
)

// Ensure, that UserRepositoryMock does implement UserRepository.
// If this is not the case, regenerate this file with moq.
var _ UserRepository = &UserRepositoryMock{}

// UserRepositoryMock is a mock implementation of UserRepository.
//
//	func TestSomethingThatUsesUserRepository(t *testing.T) {
//
//		// make and configure a mocked UserRepository
//		mockedUserRepository := &UserRepositoryMock{
//			GetUserByUsernameFunc: func(ctx context.Context, db repository.Executor, username entity.Username) (*entity.User, error) {
//				panic("mock out the GetUserByUsername method")
//			},
//			ListUsersByIdFunc: func(ctx context.Context, db repository.Executor, userIds []entity.ImmutableId) ([]*entity.User, error) {
//				panic("mock out the ListUsersById method")
//			},
//			ListUsersByUsernameFunc: func(ctx context.Context, db repository.Executor, usernames []entity.Username) ([]*entity.User, error) {
//				panic("mock out the ListUsersByUsername method")
//			},
//			StoreUserFunc: func(ctx context.Context, db repository.Executor, user *entity.User) (*entity.User, error) {
//				panic("mock out the StoreUser method")
//			},
//		}
//
//		// use mockedUserRepository in code that requires UserRepository
//		// and then make assertions.
//
//	}
type UserRepositoryMock struct {
	// GetUserByUsernameFunc mocks the GetUserByUsername method.
	GetUserByUsernameFunc func(ctx context.Context, db repository.Executor, username entity.Username) (*entity.User, error)

	// ListUsersByIdFunc mocks the ListUsersById method.
	ListUsersByIdFunc func(ctx context.Context, db repository.Executor, userIds []entity.ImmutableId) ([]*entity.User, error)

	// ListUsersByUsernameFunc mocks the ListUsersByUsername method.
	ListUsersByUsernameFunc func(ctx context.Context, db repository.Executor, usernames []entity.Username) ([]*entity.User, error)

	// StoreUserFunc mocks the StoreUser method.
	StoreUserFunc func(ctx context.Context, db repository.Executor, user *entity.User) (*entity.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetUserByUsername holds details about calls to the GetUserByUsername method.
		GetUserByUsername []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// Username is the username argument value.
			Username entity.Username
		}
		// ListUsersById holds details about calls to the ListUsersById method.
		ListUsersById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// UserIds is the userIds argument value.
			UserIds []entity.ImmutableId
		}
		// ListUsersByUsername holds details about calls to the ListUsersByUsername method.
		ListUsersByUsername []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// Usernames is the usernames argument value.
			Usernames []entity.Username
		}
		// StoreUser holds details about calls to the StoreUser method.
		StoreUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// User is the user argument value.
			User *entity.User
		}
	}
	lockGetUserByUsername   sync.RWMutex
	lockListUsersById       sync.RWMutex
	lockListUsersByUsername sync.RWMutex
	lockStoreUser           sync.RWMutex
}

// GetUserByUsername calls GetUserByUsernameFunc.
func (mock *UserRepositoryMock) GetUserByUsername(ctx context.Context, db repository.Executor, username entity.Username) (*entity.User, error) {
	if mock.GetUserByUsernameFunc == nil {
		panic("UserRepositoryMock.GetUserByUsernameFunc: method is nil but UserRepository.GetUserByUsername was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Db       repository.Executor
		Username entity.Username
	}{
		Ctx:      ctx,
		Db:       db,
		Username: username,
	}
	mock.lockGetUserByUsername.Lock()
	mock.calls.GetUserByUsername = append(mock.calls.GetUserByUsername, callInfo)
	mock.lockGetUserByUsername.Unlock()
	return mock.GetUserByUsernameFunc(ctx, db, username)
}

// GetUserByUsernameCalls gets all the calls that were made to GetUserByUsername.
// Check the length with:
//
//	len(mockedUserRepository.GetUserByUsernameCalls())
func (mock *UserRepositoryMock) GetUserByUsernameCalls() []struct {
	Ctx      context.Context
	Db       repository.Executor
	Username entity.Username
} {
	var calls []struct {
		Ctx      context.Context
		Db       repository.Executor
		Username entity.Username
	}
	mock.lockGetUserByUsername.RLock()
	calls = mock.calls.GetUserByUsername
	mock.lockGetUserByUsername.RUnlock()
	return calls
}

// ListUsersById calls ListUsersByIdFunc.
func (mock *UserRepositoryMock) ListUsersById(ctx context.Context, db repository.Executor, userIds []entity.ImmutableId) ([]*entity.User, error) {
	if mock.ListUsersByIdFunc == nil {
		panic("UserRepositoryMock.ListUsersByIdFunc: method is nil but UserRepository.ListUsersById was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Db      repository.Executor
		UserIds []entity.ImmutableId
	}{
		Ctx:     ctx,
		Db:      db,
		UserIds: userIds,
	}
	mock.lockListUsersById.Lock()
	mock.calls.ListUsersById = append(mock.calls.ListUsersById, callInfo)
	mock.lockListUsersById.Unlock()
	return mock.ListUsersByIdFunc(ctx, db, userIds)
}

// ListUsersByIdCalls gets all the calls that were made to ListUsersById.
// Check the length with:
//
//	len(mockedUserRepository.ListUsersByIdCalls())
func (mock *UserRepositoryMock) ListUsersByIdCalls() []struct {
	Ctx     context.Context
	Db      repository.Executor
	UserIds []entity.ImmutableId
} {
	var calls []struct {
		Ctx     context.Context
		Db      repository.Executor
		UserIds []entity.ImmutableId
	}
	mock.lockListUsersById.RLock()
	calls = mock.calls.ListUsersById
	mock.lockListUsersById.RUnlock()
	return calls
}

// ListUsersByUsername calls ListUsersByUsernameFunc.
func (mock *UserRepositoryMock) ListUsersByUsername(ctx context.Context, db repository.Executor, usernames []entity.Username) ([]*entity.User, error) {
	if mock.ListUsersByUsernameFunc == nil {
		panic("UserRepositoryMock.ListUsersByUsernameFunc: method is nil but UserRepository.ListUsersByUsername was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Db        repository.Executor
		Usernames []entity.Username
	}{
		Ctx:       ctx,
		Db:        db,
		Usernames: usernames,
	}
	mock.lockListUsersByUsername.Lock()
	mock.calls.ListUsersByUsername = append(mock.calls.ListUsersByUsername, callInfo)
	mock.lockListUsersByUsername.Unlock()
	return mock.ListUsersByUsernameFunc(ctx, db, usernames)
}

// ListUsersByUsernameCalls gets all the calls that were made to ListUsersByUsername.
// Check the length with:
//
//	len(mockedUserRepository.ListUsersByUsernameCalls())
func (mock *UserRepositoryMock) ListUsersByUsernameCalls() []struct {
	Ctx       context.Context
	Db        repository.Executor
	Usernames []entity.Username
} {
	var calls []struct {
		Ctx       context.Context
		Db        repository.Executor
		Usernames []entity.Username
	}
	mock.lockListUsersByUsername.RLock()
	calls = mock.calls.ListUsersByUsername
	mock.lockListUsersByUsername.RUnlock()
	return calls
}

// StoreUser calls StoreUserFunc.
func (mock *UserRepositoryMock) StoreUser(ctx context.Context, db repository.Executor, user *entity.User) (*entity.User, error) {
	if mock.StoreUserFunc == nil {
		panic("UserRepositoryMock.StoreUserFunc: method is nil but UserRepository.StoreUser was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Db   repository.Executor
		User *entity.User
	}{
		Ctx:  ctx,
		Db:   db,
		User: user,
	}
	mock.lockStoreUser.Lock()
	mock.calls.StoreUser = append(mock.calls.StoreUser, callInfo)
	mock.lockStoreUser.Unlock()
	return mock.StoreUserFunc(ctx, db, user)
}

// StoreUserCalls gets all the calls that were made to StoreUser.
// Check the length with:
//
//	len(mockedUserRepository.StoreUserCalls())
func (mock *UserRepositoryMock) StoreUserCalls() []struct {
	Ctx  context.Context
	Db   repository.Executor
	User *entity.User
} {
	var calls []struct {
		Ctx  context.Context
		Db   repository.Executor
		User *entity.User
	}
	mock.lockStoreUser.RLock()
	calls = mock.calls.StoreUser
	mock.lockStoreUser.RUnlock()
	return calls
}
