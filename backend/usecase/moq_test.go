// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package usecase

import (
	"context"
	"github.com/kngnkg/tunetrail/backend/entity"
	"github.com/kngnkg/tunetrail/backend/infra/repository"
	"sync"
)

// Ensure, that UserRepositoryMock does implement UserRepository.
// If this is not the case, regenerate this file with moq.
var _ UserRepository = &UserRepositoryMock{}

// UserRepositoryMock is a mock implementation of UserRepository.
//
//	func TestSomethingThatUsesUserRepository(t *testing.T) {
//
//		// make and configure a mocked UserRepository
//		mockedUserRepository := &UserRepositoryMock{
//			GetUserByIdFunc: func(ctx context.Context, db repository.Executor, userId entity.UserId) (*entity.User, error) {
//				panic("mock out the GetUserById method")
//			},
//			ListUsersFunc: func(ctx context.Context, db repository.Executor, filter *entity.UserFilter) ([]*entity.User, entity.UserId, error) {
//				panic("mock out the ListUsers method")
//			},
//			StoreUserFunc: func(ctx context.Context, db repository.Executor, user *entity.User) (*entity.User, error) {
//				panic("mock out the StoreUser method")
//			},
//		}
//
//		// use mockedUserRepository in code that requires UserRepository
//		// and then make assertions.
//
//	}
type UserRepositoryMock struct {
	// GetUserByIdFunc mocks the GetUserById method.
	GetUserByIdFunc func(ctx context.Context, db repository.Executor, userId entity.UserId) (*entity.User, error)

	// ListUsersFunc mocks the ListUsers method.
	ListUsersFunc func(ctx context.Context, db repository.Executor, filter *entity.UserFilter) ([]*entity.User, entity.UserId, error)

	// StoreUserFunc mocks the StoreUser method.
	StoreUserFunc func(ctx context.Context, db repository.Executor, user *entity.User) (*entity.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetUserById holds details about calls to the GetUserById method.
		GetUserById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// UserId is the userId argument value.
			UserId entity.UserId
		}
		// ListUsers holds details about calls to the ListUsers method.
		ListUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// Filter is the filter argument value.
			Filter *entity.UserFilter
		}
		// StoreUser holds details about calls to the StoreUser method.
		StoreUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Executor
			// User is the user argument value.
			User *entity.User
		}
	}
	lockGetUserById sync.RWMutex
	lockListUsers   sync.RWMutex
	lockStoreUser   sync.RWMutex
}

// GetUserById calls GetUserByIdFunc.
func (mock *UserRepositoryMock) GetUserById(ctx context.Context, db repository.Executor, userId entity.UserId) (*entity.User, error) {
	if mock.GetUserByIdFunc == nil {
		panic("UserRepositoryMock.GetUserByIdFunc: method is nil but UserRepository.GetUserById was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     repository.Executor
		UserId entity.UserId
	}{
		Ctx:    ctx,
		Db:     db,
		UserId: userId,
	}
	mock.lockGetUserById.Lock()
	mock.calls.GetUserById = append(mock.calls.GetUserById, callInfo)
	mock.lockGetUserById.Unlock()
	return mock.GetUserByIdFunc(ctx, db, userId)
}

// GetUserByIdCalls gets all the calls that were made to GetUserById.
// Check the length with:
//
//	len(mockedUserRepository.GetUserByIdCalls())
func (mock *UserRepositoryMock) GetUserByIdCalls() []struct {
	Ctx    context.Context
	Db     repository.Executor
	UserId entity.UserId
} {
	var calls []struct {
		Ctx    context.Context
		Db     repository.Executor
		UserId entity.UserId
	}
	mock.lockGetUserById.RLock()
	calls = mock.calls.GetUserById
	mock.lockGetUserById.RUnlock()
	return calls
}

// ListUsers calls ListUsersFunc.
func (mock *UserRepositoryMock) ListUsers(ctx context.Context, db repository.Executor, filter *entity.UserFilter) ([]*entity.User, entity.UserId, error) {
	if mock.ListUsersFunc == nil {
		panic("UserRepositoryMock.ListUsersFunc: method is nil but UserRepository.ListUsers was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     repository.Executor
		Filter *entity.UserFilter
	}{
		Ctx:    ctx,
		Db:     db,
		Filter: filter,
	}
	mock.lockListUsers.Lock()
	mock.calls.ListUsers = append(mock.calls.ListUsers, callInfo)
	mock.lockListUsers.Unlock()
	return mock.ListUsersFunc(ctx, db, filter)
}

// ListUsersCalls gets all the calls that were made to ListUsers.
// Check the length with:
//
//	len(mockedUserRepository.ListUsersCalls())
func (mock *UserRepositoryMock) ListUsersCalls() []struct {
	Ctx    context.Context
	Db     repository.Executor
	Filter *entity.UserFilter
} {
	var calls []struct {
		Ctx    context.Context
		Db     repository.Executor
		Filter *entity.UserFilter
	}
	mock.lockListUsers.RLock()
	calls = mock.calls.ListUsers
	mock.lockListUsers.RUnlock()
	return calls
}

// StoreUser calls StoreUserFunc.
func (mock *UserRepositoryMock) StoreUser(ctx context.Context, db repository.Executor, user *entity.User) (*entity.User, error) {
	if mock.StoreUserFunc == nil {
		panic("UserRepositoryMock.StoreUserFunc: method is nil but UserRepository.StoreUser was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Db   repository.Executor
		User *entity.User
	}{
		Ctx:  ctx,
		Db:   db,
		User: user,
	}
	mock.lockStoreUser.Lock()
	mock.calls.StoreUser = append(mock.calls.StoreUser, callInfo)
	mock.lockStoreUser.Unlock()
	return mock.StoreUserFunc(ctx, db, user)
}

// StoreUserCalls gets all the calls that were made to StoreUser.
// Check the length with:
//
//	len(mockedUserRepository.StoreUserCalls())
func (mock *UserRepositoryMock) StoreUserCalls() []struct {
	Ctx  context.Context
	Db   repository.Executor
	User *entity.User
} {
	var calls []struct {
		Ctx  context.Context
		Db   repository.Executor
		User *entity.User
	}
	mock.lockStoreUser.RLock()
	calls = mock.calls.StoreUser
	mock.lockStoreUser.RUnlock()
	return calls
}
